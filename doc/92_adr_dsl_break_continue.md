# ADR: DSL 拡張（break/continue）実装方針

- **ステータス**: 承認 (2025-12-09)

## コンテキスト
- 擬似コード DSL は最小文法を実装済み（doc/02_report_pseudo_code.md）。`break`/`continue` は予約語として確保するが未実装。
- シミュレーションとアクション図生成でループ脱出/スキップが必要になるユースケース（複雑な遷移ガードやイベントバッチ処理）が想定される。

## 考慮した選択肢
1. 例外的制御フラグ方式: `break`/`continue` を AST ノードに追加し、インタプリタでフラグ伝播で処理。
2. 低レベルジャンプ方式: AST を Control Flow Graph に変換し、ジャンプで評価。
3. 非対応維持: 将来まで実装を保留。

## 決定
- 選択肢1（制御フラグ方式）で PoC を実施する。AST ノード `Break` / `Continue` を追加し、実行エンジンでループ境界までフラグをバブルアップさせる。
- アクション図では `break` を「ループ脱出」エッジ、`continue` を「条件再評価」への戻りエッジとして描画。

## 決定の基準
- 既存 AST/インタプリタ構造への変更が最小で、実装期間が短い。
- シミュレーションのステップログ形式（stmtId, varsDelta, stateDelta, emits）を拡張せずに済む。
- 将来 CFG 化する場合にも移行が容易。

## 合意事項 (doc/02_report_pseudo_code.md との整合)
- 文法追加: `stmt ::= ... | break | continue` を追加し、`break`/`continue` は `while` / `for` ブロック配下でのみ許可する。
- エラーハンドリング: ループ外使用はパースエラーとして行番号を返す。doc/02 のエラーハンドリング方針（行番号付きメッセージ、復旧は改行までスキップ）を継承。
- AST/実行: 既存のステップログ形式を維持し、`type` フィールドに `break`/`continue` を付加するだけで互換を保つ。
- アクション図: doc/02 の DFS 生成方針に沿い、`break` をマージノードへの直接エッジ、`continue` を条件ノードへの戻りエッジとして描画。

## リスクと対応
- **ネスト深度によるフラグ伝播漏れ**: ループ境界判定を AST Visitor で共通化し、単体テストでネスト 3 段までのケースを追加。
- **シミュレーションログ肥大化**: `type` 付与のみで既存フィールドを増やさず、ログサイズ増を抑制。
- **UI ハイライトの一貫性**: `doc/27_keyboard_shortcuts.md` の図/表ショートカットに影響なし。ログビューで `break`/`continue` ステップにアイコン表示を追加予定。

## 追加テストケース (TC 番号は doc/02 に続番)
- TC-09: while 内の `break` でループ終了し、後続文が実行されること。
- TC-10: for 内の `continue` で次反復に遷移し、副作用がスキップされること。
- TC-11: ループ外での `break`/`continue` がパースエラーになること（行番号付き）。
- TC-12: ネストループで内側 break が外側へ波及しないこと。

## 結果・影響
- パーサ: トークンと文法規則を追加し、予約語衝突を解決。
- 実行エンジン: ループ実行時にフラグを判定し、`break` で即終了、`continue` で反復条件評価へスキップ。
- エラーハンドリング: ループ外での `break`/`continue` 使用はパースエラーにする。
- シミュレーションログ: 既存の stmtId ログに `type: "break"|"continue"` を含め、UI 側でハイライト可能とする。

## 次のアクション
1. Chevrotain 文法へ `break`/`continue` を追加し、ユニットテスト（TC 追加）を作成。
2. インタプリタで制御フラグ方式を実装し、既存ステップログと互換を確認。
3. アクション図生成で `break`/`continue` ノード表現を追加。
4. UX ヘルプと SRS/機能設計への追記を行い、採用可否をレビュー後、ADR を更新。
